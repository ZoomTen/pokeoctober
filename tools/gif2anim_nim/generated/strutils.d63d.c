/* Generated by Nim Compiler v2.0.4 */
#define NIM_INTBITS 64
#define NIM_EmulateOverflowChecks

#include "nimbase.h"
#undef LANGUAGE_C
#undef MIPSEB
#undef MIPSEL
#undef PPC
#undef R3000
#undef R4000
#undef i386
#undef linux
#undef mips
#undef near
#undef far
#undef powerpc
#undef unix
typedef struct NimStrPayload NimStrPayload;
typedef struct NimStringV2 NimStringV2;
struct NimStrPayload {
	NI cap;
	NIM_CHAR data[SEQ_DECL_SIZE];
};
struct NimStringV2 {
	NI len;
	NimStrPayload* p;
};
N_NIMCALL(NimStringV2, mnewString)(NI len_p0);
static N_INLINE(void, nimPrepareStrMutationV2)(NimStringV2* s_p0);
N_LIB_PRIVATE N_NIMCALL(void, nimPrepareStrMutationImpl__system_u2372)(NimStringV2* s_p0);
N_LIB_PRIVATE N_NIMCALL(void, eqcopy___stdZassertions_u16)(NimStringV2* dest_p0, NimStringV2 src_p1);
static N_INLINE(void, nimPrepareStrMutationV2)(NimStringV2* s_p0) {
	{
		NIM_BOOL T3_;
		T3_ = (NIM_BOOL)0;
		T3_ = !(((*s_p0).p == ((NimStrPayload*) NIM_NIL)));
		if (!(T3_)) goto LA4_;
		T3_ = ((NI)((*(*s_p0).p).cap & ((NI)IL64(4611686018427387904))) == ((NI)IL64(4611686018427387904)));
LA4_: ;
		if (!T3_) goto LA5_;
		nimPrepareStrMutationImpl__system_u2372(s_p0);
	}
LA5_: ;
}
N_LIB_PRIVATE N_NIMCALL(NimStringV2, nsuAlignString)(NimStringV2 s_p0, NI count_p1, NIM_CHAR padding_p2) {
	NimStringV2 result;
	result.len = 0; result.p = NIM_NIL;
	{
		NI spaces;
		if (!(s_p0.len < ((NI) (count_p1)))) goto LA3_;
		result = mnewString(count_p1);
		spaces = (NI)(((NI) (count_p1)) - s_p0.len);
		{
			NI i;
			NI colontmp_;
			NI res;
			i = (NI)0;
			colontmp_ = (NI)0;
			colontmp_ = (NI)(spaces - ((NI)1));
			res = ((NI)0);
			{
				while (1) {
					if (!(res <= colontmp_)) goto LA7;
					i = res;
					nimPrepareStrMutationV2((&result));
					result.p->data[i] = padding_p2;
					res += ((NI)1);
				} LA7: ;
			}
		}
		{
			NI i_2;
			NI colontmp__2;
			NI res_2;
			i_2 = (NI)0;
			colontmp__2 = (NI)0;
			colontmp__2 = (NI)(((NI) (count_p1)) - ((NI)1));
			res_2 = spaces;
			{
				while (1) {
					if (!(res_2 <= colontmp__2)) goto LA10;
					i_2 = res_2;
					nimPrepareStrMutationV2((&result));
					result.p->data[i_2] = s_p0.p->data[(NI)(i_2 - spaces)];
					res_2 += ((NI)1);
				} LA10: ;
			}
		}
	}
	goto LA1_;
LA3_: ;
	{
		eqcopy___stdZassertions_u16((&result), s_p0);
	}
LA1_: ;
	return result;
}
